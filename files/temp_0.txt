System.out.println(conn.getContentType()); application/java-archiveSystem.out.println(conn.getRequestProperty("User-agent"));for(Map.Entry<String, List<String>> e : conn.getHeaderFields().entrySet()) {	System.out.println(e);}=========================List listA = new ArrayList(); // +grow / +null / obj.add(index, obj) / .get(O(1)) / more lookup operationsList listB = new LinkedList(); // .get(O(n)) / more insert/remove operations than lookupList listC = new Vector(); // synchronized / ordered List listD = new Stack(); // LIFO(Last In First Out) / 							Deque dequeA = new LinkedList(); // FIFO(First In First Out) / Deque dequeB = new ArrayDeque(); // FIFO(First In First Out) / Set setA = new EnumSet(); // enumlist / orderedSet setB = new HashSet(); // list / unorderedSet setC = new LinkedHashSet(); // list / orderedSet setD = new TreeSet(); // ordered(Comparator - sort books by id) / fast.Map mapA = new HashMap(); // unsynchronized // + null //Map mapA = new Hashtable(); // synchronized // - null // =========================private enum Color {        RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255);        private int r;        private int g;        private int b;        private Color(int r, int g, int b) {            this.r = r;            this.g = g;            this.b = b;        }        public int getR() {            return r;        }        public int getG() {            return g;        }        public int getB() {            return b;        }    }	EnumSet<Color> ss = EnumSet.of(Color.RED, Color.GREEN);	========================Predicate gt_lt = i -> i>0 ; // true / false gt_lt.test(int);Function<String, Integer> length = str -> str.length(); / Integerlength.apply(string);========================public static void main(final String... args) {  final ExecutorService es = Executors.newFixedThreadPool(20);  final String ip = "127.0.0.1";  final int timeout = 200;  final List<Future<Boolean>> futures = new ArrayList<>();  for (int port = 1; port <= 65535; port++) {    futures.add(portIsOpen(es, ip, port, timeout));  }  es.shutdown();  int openPorts = 0;  for (final Future<Boolean> f : futures) {    if (f.get()) {      openPorts++;    }  }  System.out.println("There are " + openPorts + " open ports on host " + ip + " (probed with a timeout of " + timeout + "ms)");}public static Future<Boolean> portIsOpen(final ExecutorService es, final String ip, final int port, final int timeout) {  return es.submit(new Callable<Boolean>() {      @Override public Boolean call() {        try {          Socket socket = new Socket();          socket.connect(new InetSocketAddress(ip, port), timeout);          socket.close();          return true;        } catch (Exception ex) {          return false;        }      }   });}========================